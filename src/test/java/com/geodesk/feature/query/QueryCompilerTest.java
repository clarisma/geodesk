package com.geodesk.feature.query;

import com.geodesk.feature.filter.Filter;
import com.clarisma.common.fab.FabException;
import com.clarisma.common.fab.FabReader;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.collections.api.map.primitive.MutableObjectIntMap;
import org.eclipse.collections.api.map.primitive.ObjectIntMap;
import org.eclipse.collections.impl.factory.primitive.ObjectIntMaps;
import org.junit.Assert;
import org.junit.Test;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Tests the code generated by the Query Compiler.
 *
 * The following resources are needed:
 *
 * - feature/queries.fab: the query strings and the expected outcomes for various objects
 * - feature/tags.fab: objects and their tags
 * - feature/strings.txt: the global string table
 */
public class QueryCompilerTest
{
	public static final Logger log = LogManager.getLogger();
	
	String[] globalStrings;
	ObjectIntMap<String> stringsToCodes;	
	
	private List<QueryTestCase> loadQueries() throws FabException, IOException
	{
		QueryReader reader = new QueryReader();
		reader.read(getClass().getClassLoader().getResourceAsStream("feature/queries.fab"));
		return reader.cases;
	}
	
	private void loadStrings() throws IOException
	{
		MutableObjectIntMap<String> stringMap = ObjectIntMaps.mutable.empty();
		List<String> strings = new ArrayList<>();
		strings.add("");
		BufferedReader reader = new BufferedReader(new InputStreamReader(
			getClass().getClassLoader().getResourceAsStream("feature/strings.txt")));	
        for (;;) 
        {
            String s = reader.readLine();
            if (s == null) break;
            stringMap.put(s, strings.size());	// 1-based index
			strings.add(s);
        }
		globalStrings = strings.toArray(new String[0]);
		stringsToCodes = stringMap;
	}
	
	static class QueryTestCase
	{
		String query;
		String error;
		Map<String,Boolean> expected = new LinkedHashMap<>();
	}
	
	private static class QueryReader extends FabReader
	{
		List<QueryTestCase> cases = new ArrayList<>();
		QueryTestCase testCase;
		
		@Override protected void beginKey(String key, String value)
		{
			assert testCase == null;
			testCase = new QueryTestCase();
			testCase.query = value;
		}
		
		@Override protected void endKey()
		{
			cases.add(testCase);
			testCase = null;
		}
		
		@Override protected void keyValue(String key, String value)
		{
			assert testCase != null;
			if(key.equals("error"))
			{
				testCase.error = value;
				return;
			}
			assert !testCase.expected.containsKey(key);
			testCase.expected.put(key, Boolean.valueOf(value));
		}
	}

	static class TestClassLoader extends ClassLoader
	{
		public Filter loadMatcherClass(String className, byte[] code, String[] globalStrings)
		{
			Class<?> matcherClass = defineClass(className, code, 0, code.length);
			Filter filter;
			try
			{
				Constructor<?> constructor = matcherClass.getDeclaredConstructor(
					String.class.arrayType());
				// Can't pass globalStrings directly, since it is an array
				return (Filter)constructor.newInstance(new Object[]{ globalStrings });
			}
			catch (NoSuchMethodException | SecurityException | InstantiationException |
				IllegalAccessException | IllegalArgumentException | InvocationTargetException ex)
			{
				throw new QueryException(String.format(
					"Query compilation failed: %s", ex.getMessage()));
			}
		}
	}
	
	void testQuery(TagTableTester tagTableTester, QueryTestCase qtc, int count) throws IOException
	{
		Selector sel;
		QueryParser parser = new QueryParser(stringsToCodes, null); // TODO
		QueryCoder coder = new QueryCoder(stringsToCodes.get("no"));
		log.debug("Parsing query: {}", qtc.query);
		try
		{
			parser.parse(qtc.query);
			sel = parser.query();
		}
		catch(QueryException ex)
		{
			// TODO: check that correct exception sub-type is thrown
			if(qtc.error != null)
			{
				log.info("OK: Correctly threw {}: {}", qtc.error, ex.getMessage());
			}
			else
			{
				throw ex;
			}
			return;
		}
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		QueryXmlWriter out = new QueryXmlWriter(baos);
		out.writeQuery(sel);
		out.flush();
		log.debug(baos.toString());

		String className = "MatcherTest_" + count;
		TestClassLoader classLoader = new TestClassLoader();
		byte[] code = coder.createFilterClass(className, sel);

		Files.write(Path.of("c:\\geodesk\\debug\\classes\\" + className + ".class"), code);

		Filter filter = classLoader.loadMatcherClass(className, code, globalStrings);

		for(Map.Entry<String,Boolean> e: qtc.expected.entrySet())
		{
			String name = e.getKey();
			boolean expectedResult = e.getValue();
			ByteBuffer tags = tagTableTester.makeCase(name, 0, null);
			boolean result = filter.accept(tags, 0);
			if(result != expectedResult)
			{
				log.error("Tags {} failed for {}: Expected {}", name,
					qtc.query, expectedResult);
				Assert.fail();
			}
			else
			{
				log.info("OK: {} ({})", name, result);
			}
		}
	}

	@Test public void test() throws Exception
	{
		TagTableTester tagTableTester = new TagTableTester();
		loadStrings();
		List<QueryTestCase> cases = loadQueries();
		log.debug("{} queries", cases.size());
		int count = 1;
		for(QueryTestCase qtc: cases)
		{
			testQuery(tagTableTester, qtc, count++);
		}
	}

}
